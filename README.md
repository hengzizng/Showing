## Multiplication
### 1-phase
+ 행렬의 표현

    + key(i, m) value (p, a) -> A 행렬의 i번째 행 p번째 열의 값은 a이다.
    + key(i, m) value (p, a) 에서 m은 해당 a 값이 m번 계산되어야 하므로 (행렬 곱연산) 그 갯수만큼 생성한다.
    + 예시 `A 1 1 3 -> A 행렬의 1,1 value 는 3이다. `

+ 입력 파일
    + 형식 `행렬이름<tab>행번호<tab>열번호<tab>원소값`
    + 예시 `A 0 0 3`

+ 출력 파일

    + 형식 `행번호<tab>열번호<tab>원소값`
    + 예시 `0 0 1` (순서는 임의)

+ 1-phase의 특징
    + **메모리 오버헤드가 크다**. 값을 모두 메모리에 적재해야하기 때문
    + 메모리에 value가 모두 들어갈 수 있다면 **빠르다**.

---
### 2-phase

+ 행렬의 표현

    + key(i, m, p) value (a) -> A 행렬의 i번째 행 p번째 열의 값은 a이다.
    + 1-phase에서 p의 위치만 달라짐

+ Phase 동작
    + Phase1
        + Input 예시 `((1,1,1),3), ((1,1,1),2)` -> key : `(1,1,1)`, value-list : `<3,2>`
        + Output 예시 `((1,1) 6)` (`3 * 2 = 6`이 value)
    + Phase2
        + Map Output 예시 `((1,1),6), ((1,1),-5)`
        + Reduce Input 예시 `(1,1) <6, -5>`
        + Reduce Output 예시 `(1,1), 1` (`6-5 = 1`이 value)

+ 2-phase의 특징
    + **1-phase보다 메모리 비용이 적다**. 계산을 진행한 후에 적재하기 때문에

