## 💡 병렬 분산 알고리즘을 사용하는 이유

> Scaling-out is superior to Scaling-up
> 
- Scale-out : 아주 많은 값싼 서버들을 이용
- Scale-up : 적은 수의 값비싼 서버들을 이용

데이터 중심 (data-intensive) 어플리케이션 분야에서는 **Scale-out**을 더 선호한다. 

가격과 성능이 선형으로 증가하지 않기 때문이다. 두 배의 성능의 프로세서 한 개를 가진 컴퓨터의 가격이 일반 프로세서 한 개를 가진 컴퓨터 가격의 두배 보다 비싸다. 그러므로 여러 컴퓨터를 묶어서 처리해야 하기 때문에 병렬 분산 알고리즘이 필요하다.

---

## 💡 맵리듀스 프레임워크

- 값싼 컴퓨터들을 모아서 클러스터를 만들고 여기에서 빅데이터를 처리하기 위한 scalable 병렬 소프트웨어의 구현을 쉽게 할 수 있도록 도와주는 함수형 프로그래밍 모델
    - **scalable** : 사용자 수나 데이터가 급증해도 프로그램이 멈추거나 성능이 떨어지지 않는 것을 의미

데이터 중심 프로세싱에서는 한대의 컴퓨터의 능력으로는 처리하기가 어렵다. 여러 컴퓨터를 묶어서 처리해야 하는데 맵리듀스는 이러한 처리를 돕는 역할을 한다. 이름 그대로 Map단계와 Reduce단계로 이루어진다. 

먼저 Map단계에서는 흩어져 있는 데이터를 key, value로 데이터를 묶어준다. 예를 들어 key는 몇 번째 데이터인지, value는 값을 추출한 정보를 가진다. 그리고 Reduce단계는 Map단계의 key를 중심으로 필터링 및 정렬한다.

구글에서 맵리듀스 프레임워크를 만들었고 외부에서 사용할 때는 오픈소스인 하둡을 이용하여 맵리듀스 프레임워크를 구현한다. 하둡에서는 이 Map과 Reduce를 함수를 통해서 구현하고 맵리듀스 잡을 통해 제어한다. 유저는 아래 세가지 함수를 구현해서 제공해야 한다.

- Main 함수
- Map 함수 (key1, val1) -> [(key2, val2)] (리스트)
- Reduce 함수 (key2, [val2]) -> [(key3, val3)]

main 함수는 한 개의 마스터 머신에서 수행된다. 이 머신은 map 함수를 수행하기 전 전처리를 하거나 reduce 함수의 결과를 후처리하는데에 사용된다. 컴퓨팅은 유저가 정의한 map, reduce 함수 한 쌍으로 이루어진 맵리듀스 페이즈를 한 번, 혹은 여러번 수행한다.

### 📌 MapReduce Phase

![https://blog.kakaocdn.net/dn/em0bpC/btrtYUE16T9/9HWwhj0a56wzNwvEQRaCvk/img.png](https://blog.kakaocdn.net/dn/em0bpC/btrtYUE16T9/9HWwhj0a56wzNwvEQRaCvk/img.png)

### 1. 맵 (**Map**) 페이즈

- 가장 먼저 수행되며 데이터의 여러 파티션에 병렬 분산으로 호출되어 수행된다.
- 각 머신마다 수행되는 mapper는 **입력 데이터의 한 줄마다 map 함수를 호출**한다.
- (key, value) 쌍 형태로 결과를 출력하고 여러 머신에 나누어 보내며 같은 key를 가진 쌍은 같은 머신으로 보내진다.

### 2. 셔플링 (**Shuffling**) 페이즈

- 모든 머신에서 map 페이즈가 다 끝나면 시작된다.
- map 페이즈에서 각각의 머신으로 보내진 (key, value) 쌍을 **key를 기준으로 정렬한 후** , 같은 key를 가진 value-list를 만든다.
- value-list를  형태로 key에 따라 여러 머신에 분산해서 보낸다.
    
    **(key, value-list)**
    

### 3. 리듀스 (**Reduce**) 페이즈

- 모든 머신에서 shuffling 페이즈가 다 끝나면 각 머신마다 reduce 페이즈가 시작된다.
- 각각의 머신에서 해당 머신으로 보내진 **(key, value-list) 쌍 마다 reduce 함수가 호출**되며 하나의 reduce 함수가 끝나면 다음 (key, value-list) 쌍에 reduce 함수가 호출된다.
- **컴바인** (Combine) 함수
    - reduce 함수와 유사한 함수로, 각 머신에서 map 페이즈에서 map 함수의 출력 크기를 줄여 shuffling 페이즈와 reduce 페이즈의 비용을 줄여주는 데 사용된다.

## 💡 맵리듀스 입출력에 사용가능한 Default 클래스

- 하둡의 맵리듀스의 map, reduce, combine 함수 등에서 입출력에 사용할 수 있는 클래스 & 해당 자바 타입
    - Text , string
    - IntWrtable, int
    - LongWritable, long
    - FloatWritable, float
    - DoubleWriable, double
- 이 타입들을 셔플링 페이즈에서 정렬하는 데 필요한 비교 함수 등 여러 함수가 미리 정의되어 있다.
- 만일 새로운 클래스를 정의해서 입출력에 사용하고 싶다면 필요한 여러 함수도 함께 정의해야 한다.

---

## 🐘 하둡 ( Hadoop )

![https://blog.kakaocdn.net/dn/VXeW8/btrt6uq5cJ8/DXPwk28OBDgepLEvRar0H0/img.png](https://blog.kakaocdn.net/dn/VXeW8/btrt6uq5cJ8/DXPwk28OBDgepLEvRar0H0/img.png)

- Apache 프로젝트의 맵리듀스 프레임워크의 오픈 소스
- 하둡 분산 파일 시스템 (Hadoop Distributed File System- **HDFS**)
    - 빅데이터를 수천대의 값 싼 컴퓨터에 병렬 처리하기 위해 분산시켜 저장을 한다. 각 파일은 여러개의 순차적인 블록으로 저장한다.
    - 한 파일의 각각의 블록은 **fault tolerance**을 위해서 여러개로 복사되어 여러 머신에 저장된다.
    - fault tolerance : 시스템을 구성하는 부품의 일부에서 결함이 발생하여도 정상적으로 기능을 수행할 수 있는 것

### 📌 구성요소

- **MapReduce** : 소프트웨어의 수행을 분산시키는 역할
- **Hadoop Distributed File System** :데이터를 분산시키는 역할
- 하나의 Namenode, 여러 개의 Datanode
    - **Namenode** (master) : 파일 시스템을 관리하고 클라이언트가 파일에 접근 할 수 있도록 함
    - **Datanode** (slaves) : 컴퓨터에 들어있는 데이터로 접근 할 수 있도록 함
